<html>
  <head>
    <title>
      
    </title>

    <style>
      body{
        font-family: Arial, sans-serif;
        line-height: 160%;
      }

      p{
        padding: 0.25em 0;
        line-height: 160%;
      }

      hr{
        margin: 0;
        margin-top: 20px;
        line-height: 0;
        height: 0;
        border: 1px solid #ddd;
      }

      blockquote {
        margin: 20px 0 20px 0;
        border-left: 5px solid #ddd;
        padding: 0 0 0 15px;
      }

      ol, ul{
        margin-bottom: 1em;
        padding-bottom: 1em;
      }
    </style>
  </head>
  <body>
    <p><strong>Introduction</strong></p>
    <p>YSound is a NodeJS application implemented using the <a href="http://expressjs.com/">Express</a> framework for the purpose of allowing users to access the audio of youtube videos, either for streaming or downloading. My implementation lives at <a href="http://kevinrankine.com/watch">http://kevinrankine.com/watch</a>, running on an AWS EC2 m1.medium Ubuntu 12.04.3 LTS instance listening on Port 80.</p><p><strong>Tech</strong></p><p>The technologies used by YSound are an Ubuntu 12.04.3 LTS m1.medium EC2 instance, node.js, npm, ffmpeg, libmp3lame, the jade templating language, CSS, Twitter Bootstrap and client-side javascript. Node and NPM versions should be current, along with ffmpeg, which needs to have the codecs for mp3 processing to be implemented.</p><p><strong>Server-side implementation</strong>
      This project is very much modular in the sense that it's little more than the glue that strings together a lot of external tools, rather than trying to do a lot from scratch.</p><p>The application logic is contained in <code>web.js</code>. Because streaming is error prone, and the application is memory intensive, we use the <code>cluster</code> module to set up 1 master process and <code>numNodes</code> worker processes (I set <code>numNodes</code> equal to 5). When there's an error, the domain generated by the <code>domain</code> module catches the error, closes the server, and exits with return value 1. This allows one of the worker processes to fail and disconnect without causing the entire application to die. When one of them fails due to an error (most likely a streaming error due to an unexpected disconnect), the master process forks another. Originally, I tried to just keep one main process, and ignore the errors with <code>process.on("uncaughException", function () {});</code>, but this caused a lot of memory leakage. On a more powerful infrastructure, <code>numNodes</code> should obviously be higher.</p><p>The <code>http</code> module is used to setup the actual HTTP server that accesses and handles the request and listen for requests on <code>port 80</code>. The <code>express</code> module (how we interact with the Express framework) is used to instantiate an <code>app</code> object, which is how we set up our route handlers and the like. The Jade templating language is used to generate the html for the application. </p><p>The <code>ytdl</code> module is used to actually download a requested youtube video. It is then piped to an ffmpeg converter interfaced by the <code>fluent-ffmpeg</code> module, which is piped back to the client. I decided to set up streams like this (it's really the reason I chose Node), so that we wouldn't have to wait for the video to download to send something to the client. I used mp3 as the final encoding of the audio because it's pretty well supported in the <code>&lt;audio&gt;</code> element, and it's the ideal format for people who want to download rather than stream as well. The one downside of using streams rather than writing to disk is that it doesn't allow us to skip back and forth in the video, but I decided it was worth the faster use time.</p><p><strong>Front end</strong></p><p>On the "front end" the Jade templating language and Bootstrap made things pretty easy. I went for a minimalist interface/UI because I noticed that youtube music players already exist, but a lot of them are very bloated and difficult to use. The main use case for this application that I envisioned is someone really wanting to listen to a random song - a simple interface makes a lot of sense for this use. If people want something complicated, they'll probably just download music anyway, but for simple use, using youtube itself, especially on mobile (where you can't watch a video in the background), can be onerous and the images are often an unwanted distraction. I chose not to display the title of the video because that's another use case I envision, people knowing what I'm listening to and judging my poor taste. Instead I put listen on this page, because that's what people should do - search for something, find it, and simply listen.</p>
  </body>
</html>


